
# Step 5-1: 힙 (Heap) - 더 맵게 문제 풀이

## 문제 풀이 과정

1. **리스트를 순차 정렬**
2. **최소 2개의 값**을 가져와 연산
3. **최소 2개 값 제거 후** 연산한 결과를 리스트에 삽입 (순차 정렬로 삽입)

### 최악의 경우
- 수가 하나 남을 때까지 섞어야 하는 경우 `(n-1)`번의 연산 필요

### 각 단계에서 요구되는 계산량
1. 정렬된 리스트에 원소를 삽입하는 것
2. 이 때, 시간 복잡도는 `O(n)`

### 문제점
이 방식은 **O(n^2)**에 해당하는 복잡도를 가짐. 복잡도를 낮출 필요가 있음.

---

## 힙 (Heap)

### 종류
1. **Max Heap**: 최대 원소를 빠르게 찾음
2. **Min Heap**: 최소 원소를 빠르게 찾음

### 힙의 성질
- 최대/최소 원소를 **빠르게** 찾을 수 있음

### 힙 연산 (Heap Operations)
- **힙 구성**: 주어진 리스트를 힙 구조로 변환
- **삽입**: 힙에 새로운 원소를 삽입
- **삭제**: 힙에서 원소를 삭제

---

## 힙의 응용
1. **정렬 (Heap Sort)**
2. **우선순위 큐 (Priority Queue)**

---

## 힙 관련 파이썬 모듈 `heapq` 사용법

```python
import heapq
# 힙구성
heapq.heapify(L)  # 리스트 L로부터 min heap 구성

# 최소값 삭제 및 반환
m = heapq.heappop(L)  # min heap L에서 최소값 삭제 후 반환

#원소 삽입
heapq.heappush(L, x)  # min heap L에 원소 x 삽입
​```
`heapq.heapify(scoville)` 함수가 in-place로 동작하기 때문에, 반환값을 할당할 필요가 없다는 점입니다. `heapq.heapify(scoville)`는 `scoville` 리스트 자체를 힙으로 변환하고 반환값이 없기 때문에, 별도로 할당하는 것이 필요하지 않습니다.


# 6-1 동적 계획법 문제 풀이 (Dynamic Programming)

## N으로 표현

주어진 최적화 문제를 재귀적인 방식으로 보다 작은 부분 문제로 나누어, 부분 문제를 풀어 이 답들을 조합하여 전체 문제의 해답에 이르는 방식.

알고리즘 진행에 따라 동적으로 탐색해야 할 범위를 결정함으로써, 탐색 범위를 한정할 수 있다.

---

## 동적 계획법의 적용 예

### 1. 피보나치 수열
- 직전 두 항의 합이 다음 항이 되는 수열
- 복잡도: 선형 함수의 형태

### 2. Knapsack Problem
- 가장 높은 값을 가지도록 물건을 골라 배낭에 담으시오.

---

## N으로 표현 문제

- **동적 계획법으로 설계**

### 규칙 설명

1. **N을 한 번 사용해서 만들 수 있는 수**
2. **N을 두 번 사용해서 만들 수 있는 수들**
3. **N을 세 번 사용해서 만들 수 있는 수들**

### 예제) N=5

- 1번 사용 -> `5`
- 2번 사용 -> `55`, 1번 사용해서 나온 수들에 대해 `+`, `-`, `*`, `/` 연산을 통해 나온 수들
- 3번 사용 -> `555`,
    - 1번 사용해서 만든 수에 대해 `+`, `-`, `*`, `/` 2번 사용해서 나온 수들과 연산
    - 2번 사용해서 만든 수에 대해 `+`, `-`, `*`, `/` 1번 사용해서 나온 수들과 연산
- 4번 사용 -> `5555`,
    - 1번 사용해서 만든 수에 대해 `+`, `-`, `*`, `/` 3번 사용해서 나온 수들과 연산
    - 2번 사용해서 만든 수에 대해 `+`, `-`, `*`, `/` 2번 사용해서 나온 수들과 연산
    - 3번 사용해서 만든 수에 대해 `+`, `-`, `*`, `/` 1번 사용해서 나온 수들과 연산
- ...

### 일반화

1. `n` -> N을 n번 사용하여 만들 수 있는 수
    - "X" x(곱셈) n, 1번 사용해서 만들 수 있는 수 `+`, `-`, `*`, `/` n-1번 사용해서 만든 수
    - n-1번 사용해서 만든 수 `+`, `-`, `*`, `/` 1번 사용해서 만든 수

---

## 요약

문제의 성질에 따라 동적 계획법으로 풀어냄으로써 탐색해야 하는 범위를 줄일 수 있다.

( **N으로 표현 문제 다시 한번 복습하기** )
# 7-1 깊이 우선 탐색(DFS) / 너비 우선 탐색(BFS) - 여행 경로 문제 풀이

## 배경지식

### 그래프 (Graphs)
- **정점** (vertex, node)과 **간선** (edge, link)으로 구성된 구조
- **유향 그래프** (directed graph): 간선에 방향이 있는 그래프
- **무향 그래프** (undirected graph): 간선에 방향이 없는 그래프

### 스택 (Stack)
- 후입선출(LIFO) 구조. 깊이 우선 탐색(DFS)에서 사용됨.

### 큐 (Queue)
- 선입선출(FIFO) 구조. 너비 우선 탐색(BFS)에서 사용됨.

---

## 탐색 기법

### 1. 깊이 우선 탐색 (DFS; Depth-First Search)
- **방식**: 한 정점에서 인접한 모든(아직 방문하지 않은) 정점을 방문하되, 각 인접 정점을 기준으로 깊이 우선 탐색을 끝낸 후 다음 정점으로 진행.
- **사용 자료구조**: **스택**을 이용하여 어느 정점에서 DFS를 하고 있는지를 기억하고 되돌아감.

### 2. 너비 우선 탐색 (BFS; Breadth-First Search)
- **방식**: 한 정점에서 인접한 모든(아직 방문하지 않은) 정점을 방문하고, 각 방문한 인접 정점을 기준으로 너비 우선 탐색을 수행.
- **사용 자료구조**: **큐**를 이용하여 어느 정점에서 BFS를 해야 하는지를 기억하고 진행.

---

## 여행 경로 문제

### 문제 설명
여행 경로 문제는 한붓그리기 문제로, 모든 간선을 한 번씩 거쳐야 하는 상황에서 경로를 결정하는 문제입니다. 이 문제는 **깊이 우선 탐색(DFS)**을 응용하여 해결할 수 있습니다.

### 특징
- **시작 정점**: 항상 **인천공항 (ICN)**에서 출발.
- **조건**: 모든 정점을 방문하는 것이 아니라, **모든 간선**을 거쳐야 함.
- **알파벳 순서**: 여러 선택지가 있을 경우, **알파벳 순서**로 선택.

### 알고리즘 설계
1. **ICN**에서 출발하면 선택지가 2개인 상황:
    - ATL / SFO → **알파벳 순서**로 ATL 선택 후, 해당 간선을 제거.
2. 그다음 **알파벳 순서**로 계속 진행.
3. **스택**을 이용하여 재귀적 **한붓그리기**로 문제를 해결.

### 해결 전략
- 이 문제는 **재귀적인 성질**을 가진 **한붓그리기 문제**입니다.
- **깊이 우선 탐색 (DFS)**을 이용한 재귀적 탐색을 통해 해결할 수 있습니다.

---

## 경로 탐색 코드 설명

1. `routes`라는 사전을 만들어 항공권의 출발 공항을 **키**로, 도착 공항을 **값**으로 저장하는 역할을 합니다.
2. 항공권을 하나씩 순회하면서, 출발 공항을 **키**로, 그 공항에서 갈 수 있는 도착 공항 리스트를 **값**으로 추가합니다.
3. `routes.get(t[0], [])`는 출발 공항이 기존에 없으면 **빈 리스트**를 반환하고, 그 리스트에 도착 공항을 추가합니다.
4. 각 출발 공항의 도착 공항 리스트를 **역순으로 정렬**합니다. 스택에서 도착 공항을 뒤에서 꺼내기 때문에 **역순**이 효율적입니다.
5. 스택을 생성하고, `"ICN"`을 시작점으로 초기화합니다.
6. 경로를 저장할 빈 리스트 `path`를 만듭니다.
7. 스택에 공항이 남아 있는 동안 계속해서 탐색을 진행합니다.
8. 스택에서 **현재 위치**(맨 위 공항)를 가져옵니다.
9. 현재 공항이 `routes`에 없거나 더 이상 갈 수 있는 도착 공항이 없으면, 그 공항을 경로에 추가하고 **스택에서 제거**합니다.
10. 만약 더 갈 수 있는 공항이 남아 있으면, 그 도착 공항을 스택에 추가하고, 해당 공항을 리스트에서 제거합니다.
11. 스택이 비어 **경로가 완성**되면, 경로 리스트를 뒤집어 반환합니다.

---

## 요약
- 여행 경로 문제는 **재귀적 성질**을 가진 **그래프**의 **깊이 우선 탐색(DFS)**을 이용하여 해결할 수 있습니다.
- 모든 간선을 거쳐야 하며, 선택지가 여러 개일 경우 **알파벳 순서**에 따라 결정합니다.
- 스택을 활용하여 **재귀적인 한붓그리기** 방식으로 문제를 해결합니다.

```